var gdjs;(function(y){const C=new y.Logger("Light object"),g=class{constructor(t,e){this._texture=null;this._light=null;this._debugMode=!1;this._debugLight=null;this._debugGraphics=null;this._lightIconSprite=null;this._object=t,this._instanceContainer=e,this._manager=t.getObstaclesManager(),this._radius=t.getRadius();const i=t._color;this._color=[i[0]/255,i[1]/255,i[2]/255],this.updateTexture(),this._center=new Float32Array([t.x,t.y]),this._defaultVertexBuffer=new Float32Array(8),this._vertexBuffer=new Float32Array([t.x-this._radius,t.y+this._radius,t.x+this._radius,t.y+this._radius,t.x+this._radius,t.y-this._radius,t.x-this._radius,t.y-this._radius]),this._indexBuffer=new Uint16Array([0,1,2,0,2,3]),this.updateMesh(),this._isPreview=e.getGame().isPreview(),this._lightBoundingPoly=y.Polygon.createRectangle(0,0),this.updateDebugMode();const n=this._object.getInstanceContainer().getGame();if(n.isInGameEdition()){const o=n.getImageManager().getPIXITexture("InGameEditor-LightIcon");this._lightIconSprite=new PIXI.Sprite(o),this._lightIconSprite.anchor.x=.5,this._lightIconSprite.anchor.y=.5,this._debugGraphics=new PIXI.Graphics,this._debugLight=new PIXI.Container,this._debugLight.addChild(this._debugGraphics),this._debugLight.addChild(this._lightIconSprite),this._radius=0}const s=this.getRendererObject();s&&e.getLayer("").getRenderer().addRendererObject(s,t.getZOrder())}destroy(){this._lightIconSprite&&(this._lightIconSprite.removeFromParent(),this._lightIconSprite.destroy(),this._lightIconSprite=null),this._debugGraphics&&(this._debugGraphics.removeFromParent(),this._debugGraphics.destroy(),this._debugGraphics=null),this._light&&(this._light.removeFromParent(),this._light.destroy(),this._light=null)}static _verticesWithAngleComparator(t,e){return t.angle<e.angle?-1:t.angle>e.angle?1:0}static _computeClosestIntersectionPoint(t,e,i,n){const s=t.getX(),o=t.getY(),h=s+n*Math.cos(e),_=o+n*Math.sin(e);let l=n*n;const c=[null,null];for(const f of i){const d=y.Polygon.raycastTest(f,s,o,h,_);d.collision&&d.closeSqDist<=l&&(l=d.closeSqDist,c[0]=d.closeX,c[1]=d.closeY)}return c[0]&&c[1]?c:null}getRendererObject(){return this._debugLight?this._debugLight:this._light}ensureUpToDate(){if(this._object.getInstanceContainer().getGame().isInGameEdition()){if(!this._debugLight||(this._debugLight.x=this._object.getX(),this._debugLight.y=this._object.getY(),this._radius===this._object.getRadius()&&this._color[0]===this._object._color[0]&&this._color[1]===this._object._color[1]&&this._color[2]===this._object._color[2]))return;if(this._debugGraphics){this._radius=this._object.getRadius(),this._color[0]=this._object._color[0],this._color[1]=this._object._color[1],this._color[2]=this._object._color[2];const t=2;this._debugGraphics.clear(),this._debugGraphics.lineStyle(t,y.rgbToHexNumber(this._color[0],this._color[1],this._color[2]),.8),this._debugGraphics.drawCircle(0,0,Math.max(1,this._radius-t))}return}this._object.isHidden()||(this._debugGraphics&&this._updateDebugGraphics(),this._updateBuffers())}updateMesh(){if(this._object.getInstanceContainer().getGame().isInGameEdition())return;if(!PIXI.utils.isWebGLSupported()){C.warn("This device does not support webgl, which is required for Lighting Extension.");return}this.updateTexture();const t=this._texture===null?g.defaultFragmentShader:g.texturedFragmentShader,e={center:this._center,radius:this._radius,color:this._color};this._texture&&(e.uSampler=this._texture);const i=PIXI.Shader.from(g.defaultVertexShader,t,e),n=new PIXI.Geometry;n.addAttribute("aVertexPosition",this._vertexBuffer,2).addIndex(this._indexBuffer),this._light?(this._light.shader=i,this._light.geometry=n):(this._light=new PIXI.Mesh(n,i),this._light.blendMode=PIXI.BLEND_MODES.ADD)}updateRadius(){!this._light||(this._radius=this._object.getRadius(),this._light.shader.uniforms.radius=this._radius)}updateColor(){if(!this._light)return;const t=this._object._color;this._color=[t[0]/255,t[1]/255,t[2]/255],this._light.shader.uniforms.color=this._color}updateTexture(){const t=this._object.getTexture();this._texture=t!==""?this._instanceContainer.getGame().getImageManager().getPIXITexture(t):null}updateDebugMode(){!this._light||(this._debugMode=this._object.getDebugMode(),!this._debugLight&&(this._isPreview||this._debugMode)&&(this._debugLight=new PIXI.Container,this._debugLight.addChild(this._light)),this._debugMode&&!this._debugGraphics&&(this._debugGraphics=new PIXI.Graphics,this._debugLight.addChild(this._debugGraphics)),!this._debugMode&&this._debugGraphics&&(this._debugLight.removeChild(this._debugGraphics),this._debugGraphics.destroy(),this._debugGraphics=null),this.ensureUpToDate())}_updateDebugGraphics(){const t=this._debugGraphics,e=this._computeLightVertices();if(!e.length){t.clear(),t.lineStyle(1,16711680,1).moveTo(this._object.x,this._object.y).lineTo(this._object.x-this._radius,this._object.y+this._radius).lineTo(this._object.x+this._radius,this._object.y+this._radius).moveTo(this._object.x,this._object.y).lineTo(this._object.x+this._radius,this._object.y+this._radius).lineTo(this._object.x+this._radius,this._object.y-this._radius).moveTo(this._object.x,this._object.y).lineTo(this._object.x+this._radius,this._object.y-this._radius).lineTo(this._object.x-this._radius,this._object.y-this._radius).moveTo(this._object.x,this._object.y).lineTo(this._object.x-this._radius,this._object.y-this._radius).lineTo(this._object.x-this._radius,this._object.y+this._radius);return}const i=new Array(2*e.length+2);i[0]=this._object.x,i[1]=this._object.y;for(let s=2;s<2*e.length+2;s+=2)i[s]=e[s/2-1][0],i[s+1]=e[s/2-1][1];t.clear(),t.moveTo(i[2],i[3]);const n=i.length;for(let s=2;s<n;s+=2){const o=s%4==0?16711680:65280,h=s+2>=n?2:s+2,_=s+3>=n?3:s+3;t.lineStyle(1,o,1).lineTo(i[s],i[s+1]).lineTo(i[h],i[_]).moveTo(i[0],i[1]).lineTo(i[s],i[s+1]).moveTo(i[0],i[1]).lineTo(i[h],i[_])}}_updateBuffers(){if(!this._light)return;this._center[0]=this._object.x,this._center[1]=this._object.y;const t=this._computeLightVertices();if(t.length===0){this._defaultVertexBuffer[0]=this._object.x-this._radius,this._defaultVertexBuffer[1]=this._object.y+this._radius,this._defaultVertexBuffer[2]=this._object.x+this._radius,this._defaultVertexBuffer[3]=this._object.y+this._radius,this._defaultVertexBuffer[4]=this._object.x+this._radius,this._defaultVertexBuffer[5]=this._object.y-this._radius,this._defaultVertexBuffer[6]=this._object.x-this._radius,this._defaultVertexBuffer[7]=this._object.y-this._radius,this._light.shader.uniforms.center=this._center,this._light.geometry.getBuffer("aVertexPosition").update(this._defaultVertexBuffer),this._light.geometry.getIndex().update(g._defaultIndexBuffer);return}const e=t.length;let i=!1,n=null,s=null;this._vertexBuffer.length>2*e+2&&(this._vertexBuffer.length<4*e+4?(i=!0,n=this._vertexBuffer.subarray(0,2*e+2),s=this._indexBuffer.subarray(0,3*e)):(this._vertexBuffer=new Float32Array(2*e+2),this._indexBuffer=new Uint16Array(3*e))),this._vertexBuffer.length<2*e+2&&(this._vertexBuffer=new Float32Array(2*e+2),this._indexBuffer=new Uint16Array(3*e)),this._vertexBuffer[0]=this._object.x,this._vertexBuffer[1]=this._object.y;for(let o=2;o<2*e+2;o+=2)this._vertexBuffer[o]=t[o/2-1][0],this._vertexBuffer[o+1]=t[o/2-1][1];for(let o=0;o<3*e;o+=3)this._indexBuffer[o]=0,this._indexBuffer[o+1]=o/3+1,o/3+1!==e?this._indexBuffer[o+2]=o/3+2:this._indexBuffer[o+2]=1;this._light.shader.uniforms.center=this._center,i?(this._light.geometry.getBuffer("aVertexPosition").update(n),this._light.geometry.getIndex().update(s)):(this._light.geometry.getBuffer("aVertexPosition").update(this._vertexBuffer),this._light.geometry.getIndex().update(this._indexBuffer))}_computeLightVertices(){const t=[];this._manager&&this._manager.getAllObstaclesAround(this._object,this._radius,t);const e=this._object.getX()-this._radius,i=this._object.getY()-this._radius,n=this._object.getX()+this._radius,s=this._object.getY()+this._radius;if(t.length===0)return t;const o=this._object.getHitBoxes()[0];for(let r=0;r<4;r++)this._lightBoundingPoly.vertices[r][0]=o.vertices[r][0],this._lightBoundingPoly.vertices[r][1]=o.vertices[r][1];const h=[];h.push(this._lightBoundingPoly);for(let r=0;r<t.length;r++){const u=t[r].owner.getHitBoxesAround(e,i,n,s);for(const p of u)h.push(p)}let _=this._object.x+this._radius,l=this._object.x-this._radius,c=this._object.y+this._radius,f=this._object.y-this._radius;const d=[];for(let r=1;r<h.length;r++){const u=h[r].vertices,p=u.length;for(let a=0;a<p;a++)d.push(u[a]),u[a][0]<l&&(l=u[a][0]),u[a][0]>_&&(_=u[a][0]),u[a][1]<f&&(f=u[a][1]),u[a][1]>c&&(c=u[a][1])}h[0].vertices[0][0]=l,h[0].vertices[0][1]=f,h[0].vertices[1][0]=_,h[0].vertices[1][1]=f,h[0].vertices[2][0]=_,h[0].vertices[2][1]=c,h[0].vertices[3][0]=l,h[0].vertices[3][1]=c;const j=Math.sqrt(Math.max((this._object.x-l)*(this._object.x-l)+(this._object.y-f)*(this._object.y-f),(_-this._object.x)*(_-this._object.x)+(this._object.y-f)*(this._object.y-f),(_-this._object.x)*(_-this._object.x)+(c-this._object.y)*(c-this._object.y),(this._object.x-l)*(this._object.x-l)+(c-this._object.y)*(c-this._object.y)));for(let r=0;r<4;r++)d.push(h[0].vertices[r]);const b=[],G=d.length;for(let r=0;r<G;r++){const u=d[r][0]-this._object.x,p=d[r][1]-this._object.y,a=Math.atan2(p,u),I=g._computeClosestIntersectionPoint(this._object,a,h,j);I&&b.push({vertex:I,angle:a});const P=g._computeClosestIntersectionPoint(this._object,a+1e-4,h,j);P&&b.push({vertex:P,angle:a+1e-4});const B=g._computeClosestIntersectionPoint(this._object,a-1e-4,h,j);B&&b.push({vertex:B,angle:a-1e-4})}b.sort(g._verticesWithAngleComparator);const v=b.length;if(v===0)return[];const m=[b[0].vertex];for(let r=1;r<v;r++)b[r].angle!==b[r-1].angle&&m.push(b[r].vertex);return m}};let x=g;x._defaultIndexBuffer=new Uint16Array([0,1,2,0,2,3]),x.defaultVertexShader=`
  precision highp float;
  attribute vec2 aVertexPosition;

  uniform mat3 translationMatrix;
  uniform mat3 projectionMatrix;
  varying vec2 vPos;

  void main() {
      vPos = aVertexPosition;
      gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
  }`,x.defaultFragmentShader=`
  precision highp float;
  uniform vec2 center;
  uniform float radius;
  uniform vec3 color;
  varying vec2 vPos;

  void main() {
      float l = length(vPos - center);
      float intensity = 0.0;
      if(l < radius)
        intensity = clamp((radius - l)*(radius - l)/(radius*radius), 0.0, 1.0);
      gl_FragColor = vec4(color*intensity, 1.0);
  }`,x.texturedFragmentShader=`
  precision highp float;
  uniform vec2 center;
  uniform float radius;
  uniform vec3 color;
  uniform sampler2D uSampler;
  varying vec2 vPos;

  void main() {
    vec2 topleft = vec2(center.x - radius, center.y - radius);
    vec2 texCoord = (vPos - topleft)/(2.0 * radius);
    gl_FragColor = (texCoord.x > 0.0 && texCoord.x < 1.0 && texCoord.y > 0.0 && texCoord.y < 1.0)
      ? vec4(color, 1.0) * texture2D(uSampler, texCoord)
      : vec4(0.0, 0.0, 0.0, 0.0);
  }`,y.LightRuntimeObjectPixiRenderer=x,y.LightRuntimeObjectRenderer=x})(gdjs||(gdjs={}));
//# sourceMappingURL=lightruntimeobject-pixi-renderer.js.map
